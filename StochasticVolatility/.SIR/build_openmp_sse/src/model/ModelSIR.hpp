
/**
 * @file
 *
 * @author Generated by LibBi
 * $Rev$
 * $Date$
 */
#ifndef LIBBI_MODELSIR_HPP
#define LIBBI_MODELSIR_HPP


#include "var/Var0.hpp"
#include "var/Var1.hpp"
#include "var/Var2.hpp"
#include "var/Var3.hpp"
#include "var/Var4.hpp"
#include "var/Var5.hpp"
#include "var/Var6.hpp"

#include "var/VarGroupF.hpp"
#include "var/VarGroupG.hpp"
#include "var/VarGroupQ.hpp"
#include "var/VarGroupR.hpp"

#include "bi/model/Model.hpp"
#include "bi/state/State.hpp"
#include "bi/state/Mask.hpp"
#include "bi/random/Random.hpp"
#include "bi/typelist/macro_typelist.hpp"
#include "bi/typelist/macro_typetree.hpp"
#include "bi/math/loc_temp_vector.hpp"



/**
 * Model SIR.
 */
class ModelSIR : public bi::Model {
public:
  /**
   * Number of dimensions.
   */
  static const int Ndims = 0;
  
  /**
   * Size of builtin_ net.
   */
  static const int NB = 3;
  
  /**
   * Number of variables in builtin_ net.
   */
  static const int CB = 3;
  
  /**
   * Size of input net.
   */
  static const int NF = 0;
  
  /**
   * Number of variables in input net.
   */
  static const int CF = 0;
  
  /**
   * Size of noise net.
   */
  static const int NR = 0;
  
  /**
   * Number of variables in noise net.
   */
  static const int CR = 0;
  
  /**
   * Size of obs net.
   */
  static const int NO = 1;
  
  /**
   * Number of variables in obs net.
   */
  static const int CO = 1;
  
  /**
   * Size of param net.
   */
  static const int NP = 0;
  
  /**
   * Number of variables in param net.
   */
  static const int CP = 0;
  
  /**
   * Size of param_aux_ net.
   */
  static const int NPX = 0;
  
  /**
   * Number of variables in param_aux_ net.
   */
  static const int CPX = 0;
  
  /**
   * Size of state net.
   */
  static const int ND = 3;
  
  /**
   * Number of variables in state net.
   */
  static const int CD = 3;
  
  /**
   * Size of state_aux_ net.
   */
  static const int NDX = 0;
  
  /**
   * Number of variables in state_aux_ net.
   */
  static const int CDX = 0;
  
  
  /**
   * Constructor.
   */
  ModelSIR();

  
  /**
   * Get discrete time step of transition model.
   *
   * @return Time step.
   */
  static real getDelta();
  

  /**
   * Deterministically simulate the @c transition block for one
   * trajectory.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<class T1, bi::Location L>
  static void transitionSimulate(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);
      
  /**
   * Deterministically simulate the @c transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void transitionSimulates(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c transition block for one trajectory.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<class T1, bi::Location L>
  static void transitionSample(bi::Random& rng,
      const T1 t1, const T1 t2, const bool onDelta,
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Stochastically simulate the @c transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void transitionSamples(bi::Random& rng,
      const T1 t1, const T1 t2, const bool onDelta,
      bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c transition
   * block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<class T1, bi::Location L>
  static real transitionLogDensity(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);

  /**
   * Compute the log-density of query points under the @c transition
   * block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void transitionLogDensities(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Maximum log-density.
   */
  template<class T1, bi::Location L>
  static real transitionMaxLogDensity(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void transitionMaxLogDensities(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, 
      V1 lp);
  
  /**
   * Deterministically simulate the @c lookahead_transition block for one
   * trajectory.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<class T1, bi::Location L>
  static void lookaheadTransitionSimulate(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);
      
  /**
   * Deterministically simulate the @c lookahead_transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void lookaheadTransitionSimulates(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c lookahead_transition block for one trajectory.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<class T1, bi::Location L>
  static void lookaheadTransitionSample(bi::Random& rng,
      const T1 t1, const T1 t2, const bool onDelta,
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Stochastically simulate the @c lookahead_transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void lookaheadTransitionSamples(bi::Random& rng,
      const T1 t1, const T1 t2, const bool onDelta,
      bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c lookahead_transition
   * block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<class T1, bi::Location L>
  static real lookaheadTransitionLogDensity(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);

  /**
   * Compute the log-density of query points under the @c lookahead_transition
   * block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void lookaheadTransitionLogDensities(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c lookahead_transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Maximum log-density.
   */
  template<class T1, bi::Location L>
  static real lookaheadTransitionMaxLogDensity(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s,
      const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c lookahead_transition block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param onDelta Is @p t1 a multiple of discrete-time step size?
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void lookaheadTransitionMaxLogDensities(const T1 t1,
      const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, 
      V1 lp);
  
  
  /**
   * Deterministically simulate the @c parameter block for one
   * trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void parameterSimulate(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Deterministically simulate the @c parameter block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void parameterSimulates(bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c parameter block for one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void parameterSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Stochastically simulate the @c parameter block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void parameterSamples(bi::Random& rng, bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c parameter
   * block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real parameterLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Compute the log-density of query points under the @c parameter
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void parameterLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c parameter block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real parameterMaxLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c parameter block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void parameterMaxLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);
  
  /**
   * Deterministically simulate the @c initial block for one
   * trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void initialSimulate(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Deterministically simulate the @c initial block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void initialSimulates(bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c initial block for one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void initialSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Stochastically simulate the @c initial block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void initialSamples(bi::Random& rng, bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c initial
   * block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real initialLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Compute the log-density of query points under the @c initial
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void initialLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c initial block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real initialMaxLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c initial block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void initialMaxLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);
  
  /**
   * Deterministically simulate the @c observation block for one
   * trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void observationSimulate(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Deterministically simulate the @c observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void observationSimulates(bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c observation block for one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void observationSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Stochastically simulate the @c observation block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void observationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c observation
   * block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real observationLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Compute the log-density of query points under the @c observation
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void observationLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real observationMaxLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c observation block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void observationMaxLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);
  
  /**
   * Deterministically simulate the @c proposal_parameter block for one
   * trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void proposalParameterSimulate(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Deterministically simulate the @c proposal_parameter block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void proposalParameterSimulates(bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c proposal_parameter block for one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void proposalParameterSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Stochastically simulate the @c proposal_parameter block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void proposalParameterSamples(bi::Random& rng, bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c proposal_parameter
   * block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real proposalParameterLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Compute the log-density of query points under the @c proposal_parameter
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void proposalParameterLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c proposal_parameter block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real proposalParameterMaxLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c proposal_parameter block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void proposalParameterMaxLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);
  
  /**
   * Deterministically simulate the @c proposal_initial block for one
   * trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void proposalInitialSimulate(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Deterministically simulate the @c proposal_initial block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void proposalInitialSimulates(bi::State<ModelSIR,L>& s);

  /**
   * Stochastically simulate the @c proposal_initial block for one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void proposalInitialSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Stochastically simulate the @c proposal_initial block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void proposalInitialSamples(bi::Random& rng, bi::State<ModelSIR,L>& s);

  /**
   * Compute the log-density of a query point under the @c proposal_initial
   * block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real proposalInitialLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);
  
  /**
   * Compute the log-density of query points under the @c proposal_initial
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void proposalInitialLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);

  /**
   * Compute the maximum log-density of a query point under the
   * @c proposal_initial block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real proposalInitialMaxLogDensity(
      bi::State<ModelSIR,L>& s, const int p = 0);

  /**
   * Compute the maximum log-density of query points under the
   * @c proposal_initial block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void proposalInitialMaxLogDensities(
      bi::State<ModelSIR,L>& s, V1 lp);
  
  /**
   * Deterministically, and sparsely, simulate the @c observation block
   * for one trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void observationSimulate(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Deterministically, and sparsely, simulate the @c observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void observationSimulates(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);

  /**
   * Stochastically, and sparsely, simulate the @c observation block for
   * one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param Trajectory index.
   */
  template<bi::Location L>
  static void observationSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Stochastically, and sparsely, simulate the @c observation block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void observationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);
  
  /**
   * Sparsely compute the log-density of a query point under the
   * @c observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real observationLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the log-density of query points under the
   * @c observation block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void observationLogDensities(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);

  /**
   * Sparsely compute the maximum log-density of a query point under the
   * @c observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real observationMaxLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the maximum log-density of query points under the
   * @c observation block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void observationMaxLogDensities(bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);
  
  /**
   * Deterministically, and sparsely, simulate the @c lookahead_observation block
   * for one trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void lookaheadObservationSimulate(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Deterministically, and sparsely, simulate the @c lookahead_observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void lookaheadObservationSimulates(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);

  /**
   * Stochastically, and sparsely, simulate the @c lookahead_observation block for
   * one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param Trajectory index.
   */
  template<bi::Location L>
  static void lookaheadObservationSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Stochastically, and sparsely, simulate the @c lookahead_observation block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void lookaheadObservationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);
  
  /**
   * Sparsely compute the log-density of a query point under the
   * @c lookahead_observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real lookaheadObservationLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the log-density of query points under the
   * @c lookahead_observation block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void lookaheadObservationLogDensities(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);

  /**
   * Sparsely compute the maximum log-density of a query point under the
   * @c lookahead_observation block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real lookaheadObservationMaxLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the maximum log-density of query points under the
   * @c lookahead_observation block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void lookaheadObservationMaxLogDensities(bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);
  
  /**
   * Deterministically, and sparsely, simulate the @c bridge block
   * for one trajectory.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   */
  template<bi::Location L>
  static void bridgeSimulate(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Deterministically, and sparsely, simulate the @c bridge block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void bridgeSimulates(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);

  /**
   * Stochastically, and sparsely, simulate the @c bridge block for
   * one trajectory.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   * @param Trajectory index.
   */
  template<bi::Location L>
  static void bridgeSample(bi::Random& rng,
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Stochastically, and sparsely, simulate the @c bridge block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void bridgeSamples(bi::Random& rng, bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask);
  
  /**
   * Sparsely compute the log-density of a query point under the
   * @c bridge block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real bridgeLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the log-density of query points under the
   * @c bridge block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void bridgeLogDensities(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);

  /**
   * Sparsely compute the maximum log-density of a query point under the
   * @c bridge block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point. On output, contains the
   * ending state, consistent with the query point.
   * @param mask Sparsity mask.
   * @param p Trajectory index.
   *
   * @return Log-density.
   */
  template<bi::Location L>
  static real bridgeMaxLogDensity(
      bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask,
      const int p = 0);

  /**
   * Sparsely compute the maximum log-density of query points under the
   * @c bridge block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query points. On output, contains the
   * ending state, consistent with the query points.
   * @param mask Sparsity mask.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void bridgeMaxLogDensities(bi::State<ModelSIR,L>& s, const bi::Mask<L>& mask, V1 lp);
     
private:
  /*
   * Dimensions
   */

  /*
   * Variables
   */
  Var0 var0;
  Var1 var1;
  Var2 var2;
  Var3 var3;
  Var4 var4;
  Var5 var5;
  Var6 var6;
};

#include "block/Block1.hpp"
#include "block/Block2.hpp"
#include "block/Block4.hpp"
#include "block/Block5.hpp"
#include "block/Block6.hpp"
#include "block/Block7.hpp"
#include "block/Block8.hpp"
#include "block/Block10.hpp"
#include "block/Block11.hpp"


inline real ModelSIR::getDelta() {
  return Block2::getDelta();
}


template<class T1, bi::Location L>
void ModelSIR::transitionSimulate(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  transitionSimulates(t1, t2, onDelta, s);
  s.setRange(start, size);
}

template<class T1, bi::Location L>
void ModelSIR::transitionSimulates(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s) {
  Block2::simulates(t1, t2, onDelta, s);
  
}

template<class T1, bi::Location L>
void ModelSIR::transitionSample(bi::Random& rng, const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  transitionSamples(rng, t1, t2, onDelta, s);
  s.setRange(start, size);
}

template<class T1, bi::Location L>
void ModelSIR::transitionSamples(bi::Random& rng, const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s) {  Block2::samples(rng, t1, t2, onDelta, s);
  
}

template<class T1, bi::Location L>
real ModelSIR::transitionLogDensity(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  transitionLogDensities(t1, t2, onDelta, s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<class T1, bi::Location L, class V1>
void ModelSIR::transitionLogDensities(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, V1 lp) {  Block2::logDensities(t1, t2, onDelta, s, lp);
  
}

template<class T1, bi::Location L>
real ModelSIR::transitionMaxLogDensity(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  transitionMaxLogDensities(t1, t2, onDelta, s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<class T1, bi::Location L, class V1>
void ModelSIR::transitionMaxLogDensities(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, V1 lp) {  Block2::maxLogDensities(t1, t2, onDelta, s, lp);
  
}

template<class T1, bi::Location L>
void ModelSIR::lookaheadTransitionSimulate(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lookaheadTransitionSimulates(t1, t2, onDelta, s);
  s.setRange(start, size);
}

template<class T1, bi::Location L>
void ModelSIR::lookaheadTransitionSimulates(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s) {
  Block8::simulates(t1, t2, onDelta, s);
  
}

template<class T1, bi::Location L>
void ModelSIR::lookaheadTransitionSample(bi::Random& rng, const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lookaheadTransitionSamples(rng, t1, t2, onDelta, s);
  s.setRange(start, size);
}

template<class T1, bi::Location L>
void ModelSIR::lookaheadTransitionSamples(bi::Random& rng, const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s) {  Block8::samples(rng, t1, t2, onDelta, s);
  
}

template<class T1, bi::Location L>
real ModelSIR::lookaheadTransitionLogDensity(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  lookaheadTransitionLogDensities(t1, t2, onDelta, s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<class T1, bi::Location L, class V1>
void ModelSIR::lookaheadTransitionLogDensities(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, V1 lp) {  Block8::logDensities(t1, t2, onDelta, s, lp);
  
}

template<class T1, bi::Location L>
real ModelSIR::lookaheadTransitionMaxLogDensity(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  lookaheadTransitionMaxLogDensities(t1, t2, onDelta, s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<class T1, bi::Location L, class V1>
void ModelSIR::lookaheadTransitionMaxLogDensities(const T1 t1, const T1 t2, const bool onDelta, bi::State<ModelSIR,L>& s, V1 lp) {  Block8::maxLogDensities(t1, t2, onDelta, s, lp);
  
}


template<bi::Location L>
void ModelSIR::parameterSimulate(bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  parameterSimulates(s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::parameterSimulates(bi::State<ModelSIR,L>& s) {
  Block5::simulates(s);
  
}

template<bi::Location L>
void ModelSIR::parameterSample(bi::Random& rng, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  parameterSamples(rng, s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::parameterSamples(bi::Random& rng, bi::State<ModelSIR,L>& s) {
  Block5::samples(rng, s);
  
}

template<bi::Location L>
real ModelSIR::parameterLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  parameterLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::parameterLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block5::logDensities(s, lp);
  
}

template<bi::Location L>
real ModelSIR::parameterMaxLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  parameterMaxLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::parameterMaxLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block5::maxLogDensities(s, lp);
  
}

template<bi::Location L>
void ModelSIR::initialSimulate(bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  initialSimulates(s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::initialSimulates(bi::State<ModelSIR,L>& s) {
  Block1::simulates(s);
  
}

template<bi::Location L>
void ModelSIR::initialSample(bi::Random& rng, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  initialSamples(rng, s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::initialSamples(bi::Random& rng, bi::State<ModelSIR,L>& s) {
  Block1::samples(rng, s);
  
}

template<bi::Location L>
real ModelSIR::initialLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  initialLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::initialLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block1::logDensities(s, lp);
  
}

template<bi::Location L>
real ModelSIR::initialMaxLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  initialMaxLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::initialMaxLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block1::maxLogDensities(s, lp);
  
}

template<bi::Location L>
void ModelSIR::observationSimulate(bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  observationSimulates(s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::observationSimulates(bi::State<ModelSIR,L>& s) {
  Block4::simulates(s);
  
}

template<bi::Location L>
void ModelSIR::observationSample(bi::Random& rng, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  observationSamples(rng, s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::observationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s) {
  Block4::samples(rng, s);
  
}

template<bi::Location L>
real ModelSIR::observationLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  observationLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::observationLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block4::logDensities(s, lp);
  
}

template<bi::Location L>
real ModelSIR::observationMaxLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  observationMaxLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::observationMaxLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block4::maxLogDensities(s, lp);
  
}

template<bi::Location L>
void ModelSIR::proposalParameterSimulate(bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  proposalParameterSimulates(s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::proposalParameterSimulates(bi::State<ModelSIR,L>& s) {
  Block11::simulates(s);
  
}

template<bi::Location L>
void ModelSIR::proposalParameterSample(bi::Random& rng, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  proposalParameterSamples(rng, s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::proposalParameterSamples(bi::Random& rng, bi::State<ModelSIR,L>& s) {
  Block11::samples(rng, s);
  
}

template<bi::Location L>
real ModelSIR::proposalParameterLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  proposalParameterLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::proposalParameterLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block11::logDensities(s, lp);
  
}

template<bi::Location L>
real ModelSIR::proposalParameterMaxLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  proposalParameterMaxLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::proposalParameterMaxLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block11::maxLogDensities(s, lp);
  
}

template<bi::Location L>
void ModelSIR::proposalInitialSimulate(bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  proposalInitialSimulates(s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::proposalInitialSimulates(bi::State<ModelSIR,L>& s) {
  Block10::simulates(s);
  
}

template<bi::Location L>
void ModelSIR::proposalInitialSample(bi::Random& rng, bi::State<ModelSIR,L>& s, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  proposalInitialSamples(rng, s);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::proposalInitialSamples(bi::Random& rng, bi::State<ModelSIR,L>& s) {
  Block10::samples(rng, s);
  
}

template<bi::Location L>
real ModelSIR::proposalInitialLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  proposalInitialLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::proposalInitialLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block10::logDensities(s, lp);
  
}

template<bi::Location L>
real ModelSIR::proposalInitialMaxLogDensity(bi::State<ModelSIR,L>& s, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  proposalInitialMaxLogDensities(s, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::proposalInitialMaxLogDensities(bi::State<ModelSIR,L>& s, V1 lp) {
  Block10::maxLogDensities(s, lp);
  
}


template<bi::Location L>
void ModelSIR::observationSimulate(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  observationSimulates(s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::observationSimulates(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block4::simulates(s, mask);
  
}

template<bi::Location L>
void ModelSIR::observationSample(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  observationSamples(rng, s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::observationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block4::samples(rng, s, mask);
  
}

template<bi::Location L>
real ModelSIR::observationLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  observationLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::observationLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block4::logDensities(s, mask, lp);
  
}

template<bi::Location L>
real ModelSIR::observationMaxLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  observationMaxLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::observationMaxLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block4::maxLogDensities(s, mask, lp);
  
}

template<bi::Location L>
void ModelSIR::lookaheadObservationSimulate(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lookaheadObservationSimulates(s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::lookaheadObservationSimulates(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block7::simulates(s, mask);
  
}

template<bi::Location L>
void ModelSIR::lookaheadObservationSample(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lookaheadObservationSamples(rng, s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::lookaheadObservationSamples(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block7::samples(rng, s, mask);
  
}

template<bi::Location L>
real ModelSIR::lookaheadObservationLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  lookaheadObservationLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::lookaheadObservationLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block7::logDensities(s, mask, lp);
  
}

template<bi::Location L>
real ModelSIR::lookaheadObservationMaxLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  lookaheadObservationMaxLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::lookaheadObservationMaxLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block7::maxLogDensities(s, mask, lp);
  
}

template<bi::Location L>
void ModelSIR::bridgeSimulate(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  bridgeSimulates(s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::bridgeSimulates(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block6::simulates(s, mask);
  
}

template<bi::Location L>
void ModelSIR::bridgeSample(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  bridgeSamples(rng, s, mask);
  s.setRange(start, size);
}

template<bi::Location L>
void ModelSIR::bridgeSamples(bi::Random& rng, bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask) {
  Block6::samples(rng, s, mask);
  
}

template<bi::Location L>
real ModelSIR::bridgeLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  bridgeLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::bridgeLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block6::logDensities(s, mask, lp);
  
}

template<bi::Location L>
real ModelSIR::bridgeMaxLogDensity(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, const int p) {
  typename bi::loc_temp_vector<L,real>::type lp(1);
  const int start = s.start();
  const int size = s.size();
  s.setRange(p, 1);
  lp.clear();
  bridgeMaxLogDensities(s, mask, lp);
  s.setRange(start, size);
  
  return *lp.begin();
}

template<bi::Location L, class V1>
void ModelSIR::bridgeMaxLogDensities(bi::State<ModelSIR,L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  Block6::maxLogDensities(s, mask, lp);
  
}


#endif

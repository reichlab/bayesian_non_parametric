







/**
 * @file
 *
 * Automatically generated by LibBi, do not edit.
 */
#ifndef LIBBI_ACTION13_HPP
#define LIBBI_ACTION13_HPP

#include "ActionCoord13.hpp"

#include "bi/state/State.hpp"
#include "bi/state/Mask.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/math/scalar.hpp"
#include "bi/math/constant.hpp"
#include "bi/math/function.hpp"
#ifdef ENABLE_SSE
#include "bi/sse/math/scalar.hpp"
#endif

class ModelSIR;

#include "bi/random/generic.hpp"

/**
 * Action: truncated_gaussian.
 */
class Action13 {
public:
  
  /**
   * Target type.
   */
  typedef Var9 target_type;

  /**
   * Coordinate type.
   */
  typedef ActionCoord13 coord_type;

  /**
   * Size of the action.
   */
  static const int SIZE = 1;

  /**
   * Is this a matrix action?
   */
  static const bool IS_MATRIX = 0;
  
  
  
  template <bi::Location L, class CX, class PX, class OX>
  static CUDA_FUNC_BOTH void simulates(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x);
  

  
  
  template <class R1, bi::Location L, class CX, class PX, class OX>
  static CUDA_FUNC_BOTH void samples(R1& rng, bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x);
  

  
  
  template <bi::Location L, class CX, class PX, class OX, class T1>
  static CUDA_FUNC_BOTH void logDensities(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x, T1& lp);
  

  
  
  template <bi::Location L, class CX, class PX, class OX, class T1>
  static CUDA_FUNC_BOTH void maxLogDensities(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x, T1& lp);
  

};


  
  
  template <bi::Location L, class CX, class PX, class OX>
  void Action13::simulates(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x)
  
 {
    
    
    
  
  /* variables */
  
  
  const BOOST_AUTO(p_rep__, pax.template fetch<Var10>(s, p, 0));
  
  const BOOST_AUTO(Z__, pax.template fetch<Var8>(s, p, 0));
  
  const BOOST_AUTO(param_aux__12___, pax.template fetch<Var12>(s, p, 0));
  
  const BOOST_AUTO(Incidence__, pax.template fetch<Var9>(s, p, 0));
  /* inlines */
  
    const CX& cox_ = cox;
    x.template fetch<target_type>(s, p, cox_.index()) = pax.template fetch_alt<target_type>(s, p, cox_.index());
    
  }



  
  template <class R1, bi::Location L, class CX, class PX, class OX>
  void Action13::samples(R1& rng, bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x)
  
 {
  
  
  
  /* variables */
  
  
  const BOOST_AUTO(p_rep__, pax.template fetch<Var10>(s, p, 0));
  
  const BOOST_AUTO(Z__, pax.template fetch<Var8>(s, p, 0));
  
  const BOOST_AUTO(param_aux__12___, pax.template fetch<Var12>(s, p, 0));
  
  const BOOST_AUTO(Incidence__, pax.template fetch<Var9>(s, p, 0));
  /* inlines */
  
  const CX& cox_ = cox;

  real mu = (p_rep__*Z__);
  real sigma = bi::sqrt(((param_aux__12___*Z__) + BI_REAL(1)));
  
  real mn = -BI_REAL(100);
  real u = lower_truncated_gaussian(rng, mn, mu, sigma);
  

  x.template fetch<target_type>(s, p, cox_.index()) = u;
}


  
  template <bi::Location L, class CX, class PX, class OX, class T1>
  void Action13::logDensities(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x, T1& lp)
  
 {
  
  
  
  /* variables */
  
  
  const BOOST_AUTO(p_rep__, pax.template fetch<Var10>(s, p, 0));
  
  const BOOST_AUTO(Z__, pax.template fetch<Var8>(s, p, 0));
  
  const BOOST_AUTO(param_aux__12___, pax.template fetch<Var12>(s, p, 0));
  
  const BOOST_AUTO(Incidence__, pax.template fetch<Var9>(s, p, 0));
  /* inlines */
  
  const CX& cox_ = cox;

  bool inside = true;

  real mu = (p_rep__*Z__);
  real sigma = bi::sqrt(((param_aux__12___*Z__) + BI_REAL(1)));

  
  real Z = BI_REAL(1.0);
  
  
  real mn = -BI_REAL(100);
  Z -= BI_REAL(0.5)*(BI_REAL(1.0) + bi::erf((mn - mu)/(BI_REAL(1.4142135623731)*sigma)));
  
  
  real xy = pax.template fetch_alt<target_type>(s, p, cox_.index());

  
  inside = xy >= mn;
  

  if (inside) {
    lp += BI_REAL(-0.5)*bi::pow((xy - mu)/sigma, BI_REAL(2.0)) - BI_REAL(BI_HALF_LOG_TWO_PI) - bi::log(sigma) - bi::log(Z);
  } else {
    lp = -BI_INF;
  }
  
  x.template fetch<target_type>(s, p, cox_.index()) = xy;
}


  
  template <bi::Location L, class CX, class PX, class OX, class T1>
  void Action13::maxLogDensities(bi::State<ModelSIR,L>& s, const int p, const int ix, const CX& cox, const PX& pax, OX& x, T1& lp)
  
 {
  
  
  
  /* variables */
  
  
  const BOOST_AUTO(p_rep__, pax.template fetch<Var10>(s, p, 0));
  
  const BOOST_AUTO(Z__, pax.template fetch<Var8>(s, p, 0));
  
  const BOOST_AUTO(param_aux__12___, pax.template fetch<Var12>(s, p, 0));
  
  const BOOST_AUTO(Incidence__, pax.template fetch<Var9>(s, p, 0));
  /* inlines */
  
  const CX& cox_ = cox;

  bool inside = true;

  real mu = (p_rep__*Z__);
  real sigma = bi::sqrt(((param_aux__12___*Z__) + BI_REAL(1)));

  
  real Z = BI_REAL(1.0);
  
  
  real mn = -BI_REAL(100);
  Z -= BI_REAL(0.5)*(BI_REAL(1.0) + bi::erf((mn - mu)/(BI_REAL(1.4142135623731)*sigma)));
  
  
  real xy = pax.template fetch_alt<target_type>(s, p, cox_.index());

  
  lp = BI_INF;
  

  x.template fetch<target_type>(s, p, cox_.index()) = xy;
}


#endif

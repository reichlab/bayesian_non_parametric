


/**
 * @file
 *
 * @author Generated by LibBi
 * $Rev$
 * $Date$
 */
#ifdef ENABLE_GPERFTOOLS
#include "google/profiler.h"
#endif
#include "bi/init.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/mpi/mpi.hpp"




#include "model/ModelSIR.hpp"

#include "bi/ode/IntegratorConstants.hpp"
#include "bi/misc/TicToc.hpp"
#include "bi/kd/kde.hpp"

#include "bi/random/Random.hpp"

#include "bi/state/State.hpp"
#include "bi/state/MarginalMHState.hpp"
#include "bi/state/MarginalSIRState.hpp"
#include "bi/state/MarginalSISState.hpp"

#include "bi/buffer/SimulatorBuffer.hpp"
#include "bi/buffer/ParticleFilterBuffer.hpp"
#include "bi/buffer/KalmanFilterBuffer.hpp"
#include "bi/buffer/MCMCBuffer.hpp"
#include "bi/buffer/SMCBuffer.hpp"
#include "bi/buffer/SRSBuffer.hpp"

#include "bi/cache/SimulatorCache.hpp"
#include "bi/cache/AdaptivePFCache.hpp"
#include "bi/cache/BootstrapPFCache.hpp"
#include "bi/cache/ExtendedKFCache.hpp"
#include "bi/cache/MCMCCache.hpp"
#include "bi/cache/SMCCache.hpp"
#include "bi/cache/SRSCache.hpp"

#include "bi/netcdf/InputNetCDFBuffer.hpp"
#include "bi/netcdf/SimulatorNetCDFBuffer.hpp"
#include "bi/netcdf/MCMCNetCDFBuffer.hpp"
#include "bi/netcdf/SMCNetCDFBuffer.hpp"

#include "bi/null/InputNullBuffer.hpp"
#include "bi/null/SimulatorNullBuffer.hpp"
#include "bi/null/MCMCNullBuffer.hpp"
#include "bi/null/SMCNullBuffer.hpp"

#include "bi/simulator/ForcerFactory.hpp"
#include "bi/simulator/ObserverFactory.hpp"
#include "bi/simulator/SimulatorFactory.hpp"
#include "bi/adapter/AdapterFactory.hpp"
#include "bi/filter/FilterFactory.hpp"
#include "bi/sampler/SamplerFactory.hpp"
#include "bi/resampler/ResamplerFactory.hpp"
#include "bi/stopper/StopperFactory.hpp"

#ifdef ENABLE_MPI
//#include "bi/mpi/handler/HandlerFactory.hpp"
#include "bi/mpi/adapter/DistributedAdapterFactory.hpp"
#include "bi/mpi/resampler/DistributedResamplerFactory.hpp"
#include "bi/mpi/stopper/DistributedStopperFactory.hpp"
//#include "bi/mpi/TreeNetworkNode.hpp"
//#include "bi/mpi/Server.hpp"
//#include "bi/mpi/Client.hpp"
#endif

#include "boost/typeof/typeof.hpp"

#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <string>
#include <getopt.h>

#ifdef ENABLE_CUDA
#define LOCATION ON_DEVICE
#else
#define LOCATION ON_HOST
#endif

int main(int argc, char* argv[]) {
  using namespace bi;

  /* model type */
  typedef ModelSIR model_type;
  
  /* command line arguments */
  

  enum {
    INIT_FILE_ARG,
    INPUT_FILE_ARG,
    OBS_FILE_ARG,
    OUTPUT_FILE_ARG,
    INIT_NS_ARG,
    INIT_NP_ARG,
    INPUT_NS_ARG,
    INPUT_NP_ARG,
    OBS_NS_ARG,
    OBS_NP_ARG,
    SEED_ARG,
    NTHREADS_ARG,
    GPERFTOOLS_FILE_ARG,
    WITH_MPI_ARG,
    MPI_NP_ARG,
    MPI_NPERNODE_ARG,
    MPI_HOSTFILE_ARG,
    ROLE_ARG,
    SERVER_FILE_ARG,
    WITH_TRANSFORM_EXTENDED_ARG,
    WITH_TRANSFORM_PARAM_TO_STATE_ARG,
    WITH_TRANSFORM_OBS_TO_STATE_ARG,
    WITH_TRANSFORM_INITIAL_TO_PARAM_ARG,
    WITH_TRANSFORM_ITERATED_FILTERING_ARG,
    WITH_TRANSFORM_ITERATED_SMOOTHING_ARG,
    WITH_TRANSFORM_OPTIMISE_ARG,
    TRANSFORM_EXTENDED_ARG,
    TRANSFORM_PARAM_TO_STATE_ARG,
    TRANSFORM_OBS_TO_STATE_ARG,
    TRANSFORM_INITIAL_TO_PARAM_ARG,
    THREADS_ARG,
    WITH_OUTPUT_ARG,
    START_TIME_ARG,
    END_TIME_ARG,
    NOUTPUTS_ARG,
    WITH_OUTPUT_AT_OBS_ARG,
    FILTER_ARG,
    NPARTICLES_ARG,
    ESS_REL_ARG,
    RESAMPLER_ARG,
    NBRIDGES_ARG,
    STOPPER_ARG,
    STOPPER_THRESHOLD_ARG,
    STOPPER_BLOCK_ARG,
    STOPPER_MAX_ARG,
    BRIDGE_ESS_REL_ARG,
    WITH_KDE_ARG,
    B_ABS_ARG,
    B_REL_ARG,
    WITH_SHRINK_ARG,
    WITH_SORT_ARG,
    TARGET_ARG,
    SAMPLER_ARG,
    NSAMPLES_ARG,
    CONDITIONAL_PF_ARG,
    JOINT_ADAPTATION_ARG,
    NMOVES_ARG,
    TMOVES_ARG,
    SAMPLE_RESAMPLER_ARG,
    SAMPLE_ESS_REL_ARG,
    SAMPLE_STOPPER_ARG,
    SAMPLE_STOPPER_THRESHOLD_ARG,
    SAMPLE_STOPPER_MAX_ARG,
    ADAPTER_ARG,
    ADAPTER_SCALE_ARG,
    ADAPTER_ESS_REL_ARG,
    NUM_LONG_ARGS
  };
  
  
  
  BI_UNUSED std::string INIT_FILE  = std::string("");
  
  BI_UNUSED std::string INPUT_FILE  = std::string("");
  
  BI_UNUSED std::string OBS_FILE  = std::string("");
  
  BI_UNUSED std::string OUTPUT_FILE  = std::string("");
  
  BI_UNUSED int INIT_NS  = 0;
  
  BI_UNUSED int INIT_NP  = -1;
  
  BI_UNUSED int INPUT_NS  = 0;
  
  BI_UNUSED int INPUT_NP  = -1;
  
  BI_UNUSED int OBS_NS  = 0;
  
  BI_UNUSED int OBS_NP  = 0;
  
  BI_UNUSED int SEED  = 0;
  
  BI_UNUSED int NTHREADS  = 0;
  
  BI_UNUSED std::string GPERFTOOLS_FILE  = std::string("pprof.prof");
  
  BI_UNUSED bool WITH_MPI  = 0;
  
  BI_UNUSED int MPI_NP;
  
  BI_UNUSED int MPI_NPERNODE;
  
  BI_UNUSED std::string MPI_HOSTFILE;
  
  BI_UNUSED std::string ROLE  = std::string("client");
  
  BI_UNUSED std::string SERVER_FILE  = std::string("port_name");
  
  BI_UNUSED bool WITH_TRANSFORM_EXTENDED  = 0;
  
  BI_UNUSED bool WITH_TRANSFORM_PARAM_TO_STATE;
  
  BI_UNUSED bool WITH_TRANSFORM_OBS_TO_STATE;
  
  BI_UNUSED bool WITH_TRANSFORM_INITIAL_TO_PARAM  = 0;
  
  BI_UNUSED bool WITH_TRANSFORM_ITERATED_FILTERING  = 0;
  
  BI_UNUSED bool WITH_TRANSFORM_ITERATED_SMOOTHING  = 0;
  
  BI_UNUSED bool WITH_TRANSFORM_OPTIMISE  = 1;
  ;
  ;
  ;
  ;
  ;
  ;
  
  BI_UNUSED real START_TIME  = 0;
  
  BI_UNUSED real END_TIME  = 0;
  
  BI_UNUSED int NOUTPUTS  = 0;
  
  BI_UNUSED bool WITH_OUTPUT_AT_OBS  = 1;
  
  BI_UNUSED std::string FILTER  = std::string("bootstrap");
  
  BI_UNUSED int NPARTICLES  = 1;
  
  BI_UNUSED real ESS_REL  = 0.5;
  
  BI_UNUSED std::string RESAMPLER  = std::string("systematic");
  
  BI_UNUSED int C  = 0;
  
  BI_UNUSED int NBRIDGES  = 0;
  
  BI_UNUSED std::string STOPPER  = std::string("deterministic");
  
  BI_UNUSED int STOPPER_THRESHOLD  = 128;
  
  BI_UNUSED int STOPPER_BLOCK  = 128;
  
  BI_UNUSED int STOPPER_MAX  = 32768;
  ;
  ;
  
  BI_UNUSED real B_ABS;
  
  BI_UNUSED real B_REL;
  
  BI_UNUSED bool WITH_SHRINK;
  ;
  ;
  ;
  ;
  
  BI_UNUSED std::string TARGET  = std::string("posterior");
  
  BI_UNUSED std::string SAMPLER  = std::string("mh");
  
  BI_UNUSED int NSAMPLES  = 1;
  
  BI_UNUSED int CONDITIONAL_PF  = 0;
  
  BI_UNUSED int JOINT_ADAPTATION  = 0;
  
  BI_UNUSED int NMOVES  = 1;
  
  BI_UNUSED real TMOVES  = 0;
  
  BI_UNUSED std::string SAMPLE_RESAMPLER  = std::string("systematic");
  
  BI_UNUSED real SAMPLE_ESS_REL  = 0.5;
  
  BI_UNUSED std::string SAMPLE_STOPPER  = std::string("deterministic");
  
  BI_UNUSED int SAMPLE_STOPPER_THRESHOLD  = 0;
  
  BI_UNUSED int SAMPLE_STOPPER_MAX  = 0;
  
  BI_UNUSED std::string ADAPTER  = std::string("none");
  
  BI_UNUSED real ADAPTER_SCALE  = 0.5;
  
  BI_UNUSED real ADAPTER_ESS_REL  = 0.25;
   
  int c, option_index;

  option long_options[] = {
      {"init-file", required_argument, 0, INIT_FILE_ARG },
      {"input-file", required_argument, 0, INPUT_FILE_ARG },
      {"obs-file", required_argument, 0, OBS_FILE_ARG },
      {"output-file", required_argument, 0, OUTPUT_FILE_ARG },
      {"init-ns", required_argument, 0, INIT_NS_ARG },
      {"init-np", required_argument, 0, INIT_NP_ARG },
      {"input-ns", required_argument, 0, INPUT_NS_ARG },
      {"input-np", required_argument, 0, INPUT_NP_ARG },
      {"obs-ns", required_argument, 0, OBS_NS_ARG },
      {"obs-np", required_argument, 0, OBS_NP_ARG },
      {"seed", required_argument, 0, SEED_ARG },
      {"nthreads", required_argument, 0, NTHREADS_ARG },
      {"gperftools-file", required_argument, 0, GPERFTOOLS_FILE_ARG },
      {"with-mpi", required_argument, 0, WITH_MPI_ARG },
      {"mpi-np", required_argument, 0, MPI_NP_ARG },
      {"mpi-npernode", required_argument, 0, MPI_NPERNODE_ARG },
      {"mpi-hostfile", required_argument, 0, MPI_HOSTFILE_ARG },
      {"role", required_argument, 0, ROLE_ARG },
      {"server-file", required_argument, 0, SERVER_FILE_ARG },
      {"with-transform-extended", required_argument, 0, WITH_TRANSFORM_EXTENDED_ARG },
      {"with-transform-param-to-state", required_argument, 0, WITH_TRANSFORM_PARAM_TO_STATE_ARG },
      {"with-transform-obs-to-state", required_argument, 0, WITH_TRANSFORM_OBS_TO_STATE_ARG },
      {"with-transform-initial-to-param", required_argument, 0, WITH_TRANSFORM_INITIAL_TO_PARAM_ARG },
      {"with-transform-iterated-filtering", required_argument, 0, WITH_TRANSFORM_ITERATED_FILTERING_ARG },
      {"with-transform-iterated-smoothing", required_argument, 0, WITH_TRANSFORM_ITERATED_SMOOTHING_ARG },
      {"with-transform-optimise", required_argument, 0, WITH_TRANSFORM_OPTIMISE_ARG },
      {"transform-extended", required_argument, 0, TRANSFORM_EXTENDED_ARG },
      {"transform-param-to-state", required_argument, 0, TRANSFORM_PARAM_TO_STATE_ARG },
      {"transform-obs-to-state", required_argument, 0, TRANSFORM_OBS_TO_STATE_ARG },
      {"transform-initial-to-param", required_argument, 0, TRANSFORM_INITIAL_TO_PARAM_ARG },
      {"threads", required_argument, 0, THREADS_ARG },
      {"with-output", required_argument, 0, WITH_OUTPUT_ARG },
      {"start-time", required_argument, 0, START_TIME_ARG },
      {"end-time", required_argument, 0, END_TIME_ARG },
      {"noutputs", required_argument, 0, NOUTPUTS_ARG },
      {"with-output-at-obs", required_argument, 0, WITH_OUTPUT_AT_OBS_ARG },
      {"filter", required_argument, 0, FILTER_ARG },
      {"nparticles", required_argument, 0, NPARTICLES_ARG },
      {"ess-rel", required_argument, 0, ESS_REL_ARG },
      {"resampler", required_argument, 0, RESAMPLER_ARG },
      {"nbridges", required_argument, 0, NBRIDGES_ARG },
      {"stopper", required_argument, 0, STOPPER_ARG },
      {"stopper-threshold", required_argument, 0, STOPPER_THRESHOLD_ARG },
      {"stopper-block", required_argument, 0, STOPPER_BLOCK_ARG },
      {"stopper-max", required_argument, 0, STOPPER_MAX_ARG },
      {"bridge-ess-rel", required_argument, 0, BRIDGE_ESS_REL_ARG },
      {"with-kde", required_argument, 0, WITH_KDE_ARG },
      {"b-abs", required_argument, 0, B_ABS_ARG },
      {"b-rel", required_argument, 0, B_REL_ARG },
      {"with-shrink", required_argument, 0, WITH_SHRINK_ARG },
      {"with-sort", required_argument, 0, WITH_SORT_ARG },
      {"target", required_argument, 0, TARGET_ARG },
      {"sampler", required_argument, 0, SAMPLER_ARG },
      {"nsamples", required_argument, 0, NSAMPLES_ARG },
      {"conditional-pf", required_argument, 0, CONDITIONAL_PF_ARG },
      {"joint-adaptation", required_argument, 0, JOINT_ADAPTATION_ARG },
      {"nmoves", required_argument, 0, NMOVES_ARG },
      {"tmoves", required_argument, 0, TMOVES_ARG },
      {"sample-resampler", required_argument, 0, SAMPLE_RESAMPLER_ARG },
      {"sample-ess-rel", required_argument, 0, SAMPLE_ESS_REL_ARG },
      {"sample-stopper", required_argument, 0, SAMPLE_STOPPER_ARG },
      {"sample-stopper-threshold", required_argument, 0, SAMPLE_STOPPER_THRESHOLD_ARG },
      {"sample-stopper-max", required_argument, 0, SAMPLE_STOPPER_MAX_ARG },
      {"adapter", required_argument, 0, ADAPTER_ARG },
      {"adapter-scale", required_argument, 0, ADAPTER_SCALE_ARG },
      {"adapter-ess-rel", required_argument, 0, ADAPTER_ESS_REL_ARG },
      {0, 0, 0, 0}
  };
  const char* short_options = "C:P:T:K:";
  
  do {
    c = getopt_long(argc, argv, short_options, long_options, &option_index);
    if (optarg) {
      switch (c) {      
      case INIT_FILE_ARG:      
        INIT_FILE = std::string(optarg);
        break;      
      case INPUT_FILE_ARG:      
        INPUT_FILE = std::string(optarg);
        break;      
      case OBS_FILE_ARG:      
        OBS_FILE = std::string(optarg);
        break;      
      case OUTPUT_FILE_ARG:      
        OUTPUT_FILE = std::string(optarg);
        break;      
      case INIT_NS_ARG:      
        INIT_NS = atoi(optarg);
        break;      
      case INIT_NP_ARG:      
        INIT_NP = atoi(optarg);
        break;      
      case INPUT_NS_ARG:      
        INPUT_NS = atoi(optarg);
        break;      
      case INPUT_NP_ARG:      
        INPUT_NP = atoi(optarg);
        break;      
      case OBS_NS_ARG:      
        OBS_NS = atoi(optarg);
        break;      
      case OBS_NP_ARG:      
        OBS_NP = atoi(optarg);
        break;      
      case SEED_ARG:      
        SEED = atoi(optarg);
        break;      
      case NTHREADS_ARG:      
        NTHREADS = atoi(optarg);
        break;      
      case GPERFTOOLS_FILE_ARG:      
        GPERFTOOLS_FILE = std::string(optarg);
        break;      
      case WITH_MPI_ARG:      
        WITH_MPI = atoi(optarg);
        break;      
      case MPI_NP_ARG:      
        MPI_NP = atoi(optarg);
        break;      
      case MPI_NPERNODE_ARG:      
        MPI_NPERNODE = atoi(optarg);
        break;      
      case MPI_HOSTFILE_ARG:      
        MPI_HOSTFILE = std::string(optarg);
        break;      
      case ROLE_ARG:      
        ROLE = std::string(optarg);
        break;      
      case SERVER_FILE_ARG:      
        SERVER_FILE = std::string(optarg);
        break;      
      case WITH_TRANSFORM_EXTENDED_ARG:      
        WITH_TRANSFORM_EXTENDED = atoi(optarg);
        break;      
      case WITH_TRANSFORM_PARAM_TO_STATE_ARG:      
        WITH_TRANSFORM_PARAM_TO_STATE = atoi(optarg);
        break;      
      case WITH_TRANSFORM_OBS_TO_STATE_ARG:      
        WITH_TRANSFORM_OBS_TO_STATE = atoi(optarg);
        break;      
      case WITH_TRANSFORM_INITIAL_TO_PARAM_ARG:      
        WITH_TRANSFORM_INITIAL_TO_PARAM = atoi(optarg);
        break;      
      case WITH_TRANSFORM_ITERATED_FILTERING_ARG:      
        WITH_TRANSFORM_ITERATED_FILTERING = atoi(optarg);
        break;      
      case WITH_TRANSFORM_ITERATED_SMOOTHING_ARG:      
        WITH_TRANSFORM_ITERATED_SMOOTHING = atoi(optarg);
        break;      
      case WITH_TRANSFORM_OPTIMISE_ARG:      
        WITH_TRANSFORM_OPTIMISE = atoi(optarg);
        break;                                          
      case START_TIME_ARG:      
        START_TIME = atof(optarg);
        break;      
      case END_TIME_ARG:      
        END_TIME = atof(optarg);
        break;      
      case NOUTPUTS_ARG:      
        NOUTPUTS = atoi(optarg);
        break;      
      case WITH_OUTPUT_AT_OBS_ARG:      
        WITH_OUTPUT_AT_OBS = atoi(optarg);
        break;      
      case FILTER_ARG:      
        FILTER = std::string(optarg);
        break;      
      case NPARTICLES_ARG:      
        NPARTICLES = atoi(optarg);
        break;      
      case ESS_REL_ARG:      
        ESS_REL = atof(optarg);
        break;      
      case RESAMPLER_ARG:      
        RESAMPLER = std::string(optarg);
        break;      
      case 'C':      
        C = atoi(optarg);
        break;      
      case NBRIDGES_ARG:      
        NBRIDGES = atoi(optarg);
        break;      
      case STOPPER_ARG:      
        STOPPER = std::string(optarg);
        break;      
      case STOPPER_THRESHOLD_ARG:      
        STOPPER_THRESHOLD = atoi(optarg);
        break;      
      case STOPPER_BLOCK_ARG:      
        STOPPER_BLOCK = atoi(optarg);
        break;      
      case STOPPER_MAX_ARG:      
        STOPPER_MAX = atoi(optarg);
        break;                  
      case B_ABS_ARG:      
        B_ABS = atof(optarg);
        break;      
      case B_REL_ARG:      
        B_REL = atof(optarg);
        break;      
      case WITH_SHRINK_ARG:      
        WITH_SHRINK = atoi(optarg);
        break;                              
      case TARGET_ARG:      
        TARGET = std::string(optarg);
        break;      
      case SAMPLER_ARG:      
        SAMPLER = std::string(optarg);
        break;      
      case NSAMPLES_ARG:      
        NSAMPLES = atoi(optarg);
        break;      
      case CONDITIONAL_PF_ARG:      
        CONDITIONAL_PF = atoi(optarg);
        break;      
      case JOINT_ADAPTATION_ARG:      
        JOINT_ADAPTATION = atoi(optarg);
        break;      
      case NMOVES_ARG:      
        NMOVES = atoi(optarg);
        break;      
      case TMOVES_ARG:      
        TMOVES = atof(optarg);
        break;      
      case SAMPLE_RESAMPLER_ARG:      
        SAMPLE_RESAMPLER = std::string(optarg);
        break;      
      case SAMPLE_ESS_REL_ARG:      
        SAMPLE_ESS_REL = atof(optarg);
        break;      
      case SAMPLE_STOPPER_ARG:      
        SAMPLE_STOPPER = std::string(optarg);
        break;      
      case SAMPLE_STOPPER_THRESHOLD_ARG:      
        SAMPLE_STOPPER_THRESHOLD = atoi(optarg);
        break;      
      case SAMPLE_STOPPER_MAX_ARG:      
        SAMPLE_STOPPER_MAX = atoi(optarg);
        break;      
      case ADAPTER_ARG:      
        ADAPTER = std::string(optarg);
        break;      
      case ADAPTER_SCALE_ARG:      
        ADAPTER_SCALE = atof(optarg);
        break;      
      case ADAPTER_ESS_REL_ARG:      
        ADAPTER_ESS_REL = atof(optarg);
        break;      }
    }
  } while (c != -1);


  
  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  boost::mpi::communicator world;
  const int rank = world.rank();
  const int size = world.size();
  NPARTICLES /= size;
  if (size > 1) {
    std::stringstream suffix;
    suffix << "." << rank;
    OUTPUT_FILE += suffix.str();
  }
  //TreeNetworkNode node;
  #else
  const int rank = 0;
  const int size = 1;
  #endif
    
  /* bi init */
  bi_init(NTHREADS);

  /* random number generator */
  Random rng(SEED);

  /* model */
  model_type m;

  /* input file */
  
  InputNullBuffer bufInput(m);
  
  
  /* init file */
  
  InputNetCDFBuffer bufInit(m, INIT_FILE, INIT_NS, INIT_NP);
  

  /* obs file */
  
  InputNetCDFBuffer bufObs(m, OBS_FILE, OBS_NS, OBS_NP);
  

  /* schedule */
  Schedule sched(m, START_TIME, END_TIME, NOUTPUTS, NBRIDGES, bufInput, bufObs, WITH_OUTPUT_AT_OBS);

  /* numbers of particles */
  NPARTICLES = bi::roundup(NPARTICLES);
  STOPPER_MAX = bi::roundup(STOPPER_MAX);
  STOPPER_BLOCK = bi::roundup(STOPPER_BLOCK);

  /* output */
  
    
      
      typedef MCMCNetCDFBuffer buffer_type;
      
      MCMCBuffer<MCMCCache<LOCATION,buffer_type> > out(m, NSAMPLES, sched.numOutputs(), OUTPUT_FILE, REPLACE, MULTI);
    
  
  
  /* resampler for x-particles */
  
  BOOST_AUTO(filterResam, ResamplerFactory::createSystematicResampler(ESS_REL));
  
    
  /* stopper for x-particles */
  
  BOOST_AUTO(filterStopper, (StopperFactory::createDefaultStopper(NPARTICLES, STOPPER_MAX, sched.numObs())));
  
 
  /* resampler for theta-particles */
  #ifdef ENABLE_MPI
  #define SAMPLER_RESAMPLER_FACTORY DistributedResamplerFactory
  #else
  #define SAMPLER_RESAMPLER_FACTORY ResamplerFactory
  #endif
  
  BOOST_AUTO(sampleResam, SAMPLER_RESAMPLER_FACTORY::createSystematicResampler(SAMPLE_ESS_REL, TMOVES > 0));
  
    
  /* stopper for theta-particles */
  #ifdef ENABLE_MPI
  #define SAMPLER_STOPPER_FACTORY DistributedStopperFactory
  #else
  #define SAMPLER_STOPPER_FACTORY StopperFactory
  #endif
  
  BOOST_AUTO(sampleStopper, (SAMPLER_STOPPER_FACTORY::createDefaultStopper(NPARTICLES, STOPPER_MAX, sched.numObs())));
  

  /* adapter for theta-particles */
  #ifdef ENABLE_MPI
  #define SAMPLER_ADAPTER_FACTORY DistributedAdapterFactory
  #else
  #define SAMPLER_ADAPTER_FACTORY AdapterFactory
  #endif
  
  BOOST_AUTO(sampleAdapter, (SAMPLER_ADAPTER_FACTORY::createGaussianAdapter(false, ADAPTER_SCALE, ADAPTER_ESS_REL)));
  
  
  /* client/server setup */
  //#ifdef ENABLE_MPI
  //Client client(node);
  //Server server(node);
  //std::string port_name;
  
  //if (ROLE.compare("server") == 0) {
  //  server.open();
  //  std::ofstream bufServer(SERVER_FILE.c_str());
  //  bufServer << server.getPortName();
  //  bufServer.close();
  //  BOOST_AUTO(handler, (HandlerFactory::createMarginalSISHandler(m, sched.numObs(), sampleAdapter, sampleStopper, node)));
  //  server.run(*handler);
  //  delete handler;
  //  server.close();
  //  exit(0);
  //} else {
  //  std::ifstream bufServer(SERVER_FILE.c_str());
  //  bufServer >> port_name;
  //  bufServer.close();
  //  //client.connect(port_name.c_str());
  //}
  //#endif
  
  /* state */
  
    
    typedef BootstrapPFState<model_type,LOCATION> state_type;
    typedef ParticleFilterBuffer<BootstrapPFCache<LOCATION> > cache_type;
    
    
    MarginalMHState<model_type,LOCATION,state_type,cache_type> s(m, NPARTICLES, sched.numObs(), sched.numOutputs());
    
  

  /* simulator */
  BOOST_AUTO(in, ForcerFactory<LOCATION>::create(bufInput));
  BOOST_AUTO(obs, ObserverFactory<LOCATION>::create(bufObs));

  /* filter */
  
  BOOST_AUTO(filter, (FilterFactory::createBootstrapPF(m, *in, *obs, *filterResam)));
  
  
  /* sampler */
  
  
  BOOST_AUTO(sampler, SamplerFactory::createMarginalMH(m, *filter));
  
  
  
  /* sample */
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  #endif

  
  sampler->sample(rng, sched.begin(), sched.end(), s, NSAMPLES, out, bufInit);
  
  out.flush();
  
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStop();
  #endif
  
  //#ifdef ENABLE_MPI
  //client.disconnect();
  //#endif
}
